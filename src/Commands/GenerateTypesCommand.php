<?php

declare(strict_types=1);

namespace Stumason\Claudavel\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\File;
use ReflectionClass;
use ReflectionNamedType;
use ReflectionProperty;

use function Laravel\Prompts\info;
use function Laravel\Prompts\warning;

class GenerateTypesCommand extends Command
{
    protected $signature = 'types:generate
                            {--output=resources/js/types/generated.d.ts : Output file path}
                            {--dto-path=app/DataTransferObjects : Path to scan for DTOs}';

    protected $description = 'Generate TypeScript interfaces from PHP DTOs';

    /** @var array<string, string> */
    private array $phpToTsTypes = [
        'int' => 'number',
        'integer' => 'number',
        'float' => 'number',
        'double' => 'number',
        'string' => 'string',
        'bool' => 'boolean',
        'boolean' => 'boolean',
        'array' => 'unknown[]',
        'object' => 'Record<string, unknown>',
        'mixed' => 'unknown',
        'null' => 'null',
        'DateTime' => 'string',
        'DateTimeInterface' => 'string',
        'DateTimeImmutable' => 'string',
        'Carbon' => 'string',
        'Carbon\\Carbon' => 'string',
        'Illuminate\\Support\\Carbon' => 'string',
    ];

    public function handle(): int
    {
        $dtoPath = base_path($this->option('dto-path'));
        $outputPath = base_path($this->option('output'));

        if (! File::isDirectory($dtoPath)) {
            warning("DTO directory not found: {$dtoPath}");
            warning('Run `php artisan claudavel:install` first or create DTOs with `php artisan make:dto`');

            return self::FAILURE;
        }

        $files = File::glob("{$dtoPath}/*.php");

        if (empty($files)) {
            warning('No DTOs found in '.$dtoPath);
            info('Create DTOs with: php artisan make:dto UserData --properties=id:int,name:string');

            return self::SUCCESS;
        }

        $interfaces = [];
        $interfaces[] = '// Auto-generated by `php artisan types:generate`';
        $interfaces[] = '// Do not edit manually - regenerate after DTO changes';
        $interfaces[] = '';

        foreach ($files as $file) {
            $className = pathinfo($file, PATHINFO_FILENAME);
            $fqcn = "App\\DataTransferObjects\\{$className}";

            if (! class_exists($fqcn)) {
                // Try to load it
                require_once $file;
            }

            if (! class_exists($fqcn)) {
                warning("Could not load class: {$fqcn}");

                continue;
            }

            try {
                $interface = $this->generateInterface($fqcn);
                if ($interface) {
                    $interfaces[] = $interface;
                }
            } catch (\Throwable $e) {
                warning("Error processing {$className}: {$e->getMessage()}");
            }
        }

        File::ensureDirectoryExists(dirname($outputPath));
        File::put($outputPath, implode("\n", $interfaces));

        info("Generated TypeScript types: {$outputPath}");
        $this->components->bulletList([
            'Import with: import type { UserData } from \'@/types/generated\'',
            'Regenerate after DTO changes: php artisan types:generate',
        ]);

        return self::SUCCESS;
    }

    private function generateInterface(string $fqcn): ?string
    {
        $reflection = new ReflectionClass($fqcn);
        $className = $reflection->getShortName();

        // Only process readonly classes (DTOs)
        if (! $reflection->isReadOnly() && ! str_ends_with($className, 'Data')) {
            return null;
        }

        $properties = $reflection->getProperties(ReflectionProperty::IS_PUBLIC);

        if (empty($properties)) {
            return null;
        }

        $lines = ["export interface {$className} {"];

        foreach ($properties as $property) {
            $type = $this->getTypeScriptType($property);
            $name = $property->getName();

            // Check if nullable
            $phpType = $property->getType();
            $nullable = $phpType instanceof ReflectionNamedType && $phpType->allowsNull();
            $optional = $nullable ? '?' : '';

            $lines[] = "    {$name}{$optional}: {$type};";
        }

        $lines[] = '}';
        $lines[] = '';

        return implode("\n", $lines);
    }

    private function getTypeScriptType(ReflectionProperty $property): string
    {
        $type = $property->getType();

        if (! $type instanceof ReflectionNamedType) {
            return 'unknown';
        }

        $typeName = $type->getName();

        // Handle arrays with docblock hints (check both @var and @param for constructor-promoted properties)
        if ($typeName === 'array') {
            $docComment = $property->getDocComment();

            // Also check constructor docblock for @param annotations (constructor promotion)
            $constructorDoc = '';
            $class = $property->getDeclaringClass();
            $constructor = $class->getConstructor();
            if ($constructor) {
                $constructorDoc = $constructor->getDocComment() ?: '';
            }

            $combinedDoc = $docComment.$constructorDoc;
            $propertyName = $property->getName();

            // Try @param first (for constructor-promoted properties) - requires property name match
            if (preg_match('/@param\s+array<(\w+),\s*(\w+)>\s+\$'.preg_quote($propertyName, '/').'/', $combinedDoc, $matches)) {
                $keyType = $matches[1];
                $valueType = $matches[2];
                $tsValueType = $this->phpToTsTypes[$valueType] ?? $valueType;

                // If key is string, it's an associative array -> Record<string, T>
                if ($keyType === 'string') {
                    return "Record<string, {$tsValueType}>";
                }

                // If key is int, it's a numeric array -> T[]
                return "{$tsValueType}[]";
            }

            // Try @var (for regular properties with docblock)
            if (preg_match('/@var\s+array<(\w+),\s*(\w+)>/', $docComment ?: '', $matches)) {
                $keyType = $matches[1];
                $valueType = $matches[2];
                $tsValueType = $this->phpToTsTypes[$valueType] ?? $valueType;

                if ($keyType === 'string') {
                    return "Record<string, {$tsValueType}>";
                }

                return "{$tsValueType}[]";
            }

            // Fallback for untyped arrays
            return 'unknown[]';
        }

        // Check our mapping
        if (isset($this->phpToTsTypes[$typeName])) {
            return $this->phpToTsTypes[$typeName];
        }

        // Handle other DTO references
        if (str_ends_with($typeName, 'Data')) {
            return class_basename($typeName);
        }

        // Handle collections
        if (str_contains($typeName, 'Collection')) {
            return 'unknown[]';
        }

        return 'unknown';
    }
}
