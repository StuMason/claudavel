<?php

declare(strict_types=1);

namespace Stumason\Claudavel\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\File;
use ReflectionClass;
use ReflectionNamedType;
use ReflectionProperty;

use function Laravel\Prompts\info;
use function Laravel\Prompts\warning;

class GenerateTypesCommand extends Command
{
    protected $signature = 'types:generate
                            {--output=resources/js/types/generated.d.ts : Output file path}
                            {--dto-path=app/DataTransferObjects : Path to scan for DTOs}';

    protected $description = 'Generate TypeScript interfaces from PHP DTOs';

    /** @var array<string, string> */
    private array $phpToTsTypes = [
        'int' => 'number',
        'integer' => 'number',
        'float' => 'number',
        'double' => 'number',
        'string' => 'string',
        'bool' => 'boolean',
        'boolean' => 'boolean',
        'array' => 'unknown[]',
        'object' => 'Record<string, unknown>',
        'mixed' => 'unknown',
        'null' => 'null',
        'DateTime' => 'string',
        'DateTimeInterface' => 'string',
        'DateTimeImmutable' => 'string',
        'Carbon' => 'string',
        'Carbon\\Carbon' => 'string',
        'Illuminate\\Support\\Carbon' => 'string',
    ];

    public function handle(): int
    {
        $dtoPath = base_path($this->option('dto-path'));
        $outputPath = base_path($this->option('output'));

        if (! File::isDirectory($dtoPath)) {
            warning("DTO directory not found: {$dtoPath}");
            warning('Run `php artisan claudavel:install` first or create DTOs with `php artisan make:dto`');

            return self::FAILURE;
        }

        $files = File::glob("{$dtoPath}/*.php");

        if (empty($files)) {
            warning('No DTOs found in '.$dtoPath);
            info('Create DTOs with: php artisan make:dto UserData --properties=id:int,name:string');

            return self::SUCCESS;
        }

        $interfaces = [];
        $interfaces[] = '// Auto-generated by `php artisan types:generate`';
        $interfaces[] = '// Do not edit manually - regenerate after DTO changes';
        $interfaces[] = '';

        foreach ($files as $file) {
            $className = pathinfo($file, PATHINFO_FILENAME);
            $fqcn = "App\\DataTransferObjects\\{$className}";

            if (! class_exists($fqcn)) {
                // Try to load it
                require_once $file;
            }

            if (! class_exists($fqcn)) {
                warning("Could not load class: {$fqcn}");

                continue;
            }

            try {
                $interface = $this->generateInterface($fqcn);
                if ($interface) {
                    $interfaces[] = $interface;
                }
            } catch (\Throwable $e) {
                warning("Error processing {$className}: {$e->getMessage()}");
            }
        }

        File::ensureDirectoryExists(dirname($outputPath));
        File::put($outputPath, implode("\n", $interfaces));

        info("Generated TypeScript types: {$outputPath}");
        $this->components->bulletList([
            'Import with: import type { UserData } from \'@/types/generated\'',
            'Regenerate after DTO changes: php artisan types:generate',
        ]);

        return self::SUCCESS;
    }

    private function generateInterface(string $fqcn): ?string
    {
        $reflection = new ReflectionClass($fqcn);
        $className = $reflection->getShortName();

        // Only process readonly classes (DTOs)
        if (! $reflection->isReadOnly() && ! str_ends_with($className, 'Data')) {
            return null;
        }

        $properties = $reflection->getProperties(ReflectionProperty::IS_PUBLIC);

        if (empty($properties)) {
            return null;
        }

        $lines = ["export interface {$className} {"];

        foreach ($properties as $property) {
            $type = $this->getTypeScriptType($property);
            $name = $property->getName();

            // Check if nullable
            $phpType = $property->getType();
            $nullable = $phpType instanceof ReflectionNamedType && $phpType->allowsNull();
            $optional = $nullable ? '?' : '';

            $lines[] = "    {$name}{$optional}: {$type};";
        }

        $lines[] = '}';
        $lines[] = '';

        return implode("\n", $lines);
    }

    private function getTypeScriptType(ReflectionProperty $property): string
    {
        $type = $property->getType();

        if (! $type instanceof ReflectionNamedType) {
            return 'unknown';
        }

        $typeName = $type->getName();

        // Check our mapping
        if (isset($this->phpToTsTypes[$typeName])) {
            return $this->phpToTsTypes[$typeName];
        }

        // Handle arrays with docblock hints
        $docComment = $property->getDocComment();
        if ($docComment && preg_match('/@var\s+array<[^,]+,\s*(\w+)>/', $docComment, $matches)) {
            $innerType = $this->phpToTsTypes[$matches[1]] ?? $matches[1];

            return "{$innerType}[]";
        }

        // Handle other DTO references
        if (str_ends_with($typeName, 'Data')) {
            return class_basename($typeName);
        }

        // Handle collections
        if (str_contains($typeName, 'Collection')) {
            return 'unknown[]';
        }

        return 'unknown';
    }
}
